<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>pDAI Price+Time Lock</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #050815;
      color: #f3f4f6;
      margin: 0;
      padding: 16px;
    }
    h1, h2 { margin-top: 0; }
    .card {
      background: #0b1020;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    }
    .row { display: flex; flex-wrap: wrap; gap: 16px; }
    .col { flex: 1 1 280px; }
    input, button {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #f9fafb;
      font-size: 14px;
    }
    input[type="datetime-local"] { color-scheme: dark; }
    button {
      cursor: pointer;
      border: none;
      background: #16a34a;
      font-weight: 600;
    }
    button[disabled] { opacity: 0.5; cursor: not-allowed; }
    label { display: block; margin-bottom: 4px; font-size: 13px; color: #9ca3af; }
    .field { margin-bottom: 12px; }
    .small { font-size: 12px; color: #9ca3af; }
    .tag {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      background: #111827;
      border: 1px solid #1f2937;
      margin-right: 6px;
      margin-top: 4px;
    }
    .status-ok { color: #4ade80; }
    .status-warn { color: #facc15; }
    .status-bad { color: #f87171; }
    .mono { font-family: monospace; font-size: 12px; }
  </style>
</head>

<body>
  <h1>pDAI Price + Time Lock</h1>

  <div class="card">
    <button id="connectBtn">Connect Wallet</button>
    <span id="walletAddress" class="mono"></span>
    <div class="small" id="networkInfo"></div>
  </div>

  <div class="row">
    <div class="col">
      <div class="card">
        <h2>Create New Lock</h2>
        <form id="createForm">
          <div class="field">
            <label for="targetPrice">Target price (DAI per 1 pDAI)</label>
            <input id="targetPrice" type="text" placeholder="e.g. 0.0100" required />
          </div>

          <div class="field">
            <label for="unlockDateTime">Backup unlock date &amp; time</label>
            <input id="unlockDateTime" type="datetime-local" required />
          </div>

          <button type="submit" id="createBtn">Create Vault</button>
          <div class="small" id="createStatus"></div>
        </form>
      </div>
    </div>

    <div class="col">
      <div class="card">
        <h2>Global Price Feed</h2>
        <div id="globalPrice" style="margin-top:8px;font-size:14px;"></div>
        <div class="small" id="globalPriceRaw"></div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>Your Locks</h2>
    <div id="locksContainer" class="small">Connect to load locks.</div>
  </div>

  <!-- Load ethers v5 securely -->
  <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"
          onload="window.ethersLoaded = true;"></script>

  <script>
  (function waitForEthers() {
    if (!window.ethersLoaded || !window.ethers) {
      return setTimeout(waitForEthers, 50);
    }

    // Ethers is now guaranteed available
    const ethers = window.ethers;

    // ----------------------------------------
    // CONTRACT ADDRESSES
    // ----------------------------------------
    const FACTORY_ADDRESS = "0xaA5866aAA1184730Dd2926Ed83aCCbD89F128d1d";
    const PDAI_ADDRESS    = "0x6B175474E89094C44Da98B954EedeAC495271d0F";
    const DAI_ADDRESS     = "0xefd766ccb38eaf1dfd701853bfce31359239f305"; // correct!
    const PAIR_ADDRESS    = "0x1D2be6eFf95Ac5C380a8D6a6143b6a97dd9D8712";

    // ----------------------------------------
    // ABIs
    // ----------------------------------------
    const factoryAbi = [
      "event VaultCreated(address indexed owner, address vault, uint256 priceThreshold1e18, uint256 unlockTime)",
      "function createVault(uint256 priceThreshold1e18, uint256 unlockTime) external returns (address)"
    ];

    const vaultAbi = [
      "function owner() view returns (address)",
      "function priceThreshold() view returns (uint256)",
      "function unlockTime() view returns (uint256)",
      "function withdrawn() view returns (bool)",
      "function currentPricePDAIinDAI() view returns (uint256)",
      "function canWithdraw() view returns (bool)",
      "function withdraw() external"
    ];

    const pairAbi = [
      "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)"
    ];

    const erc20Abi = [
      "function balanceOf(address) view returns (uint256)"
    ];

    // ----------------------------------------
    // STATE
    // ----------------------------------------
    let provider, signer, userAddress;
    let factory, pdai, pairContract;
    let locks = [];
    let countdownInterval;

    // ----------------------------------------
    // UI elements
    // ----------------------------------------
    const connectBtn = document.getElementById("connectBtn");
    const walletSpan = document.getElementById("walletAddress");
    const networkInfo = document.getElementById("networkInfo");
    const createForm = document.getElementById("createForm");
    const targetPriceInput = document.getElementById("targetPrice");
    const unlockDateTimeInput = document.getElementById("unlockDateTime");
    const createStatus = document.getElementById("createStatus");
    const createBtn = document.getElementById("createBtn");
    const locksContainer = document.getElementById("locksContainer");
    const globalPriceDiv = document.getElementById("globalPrice");
    const globalPriceRawDiv = document.getElementById("globalPriceRaw");

    // ----------------------------------------
    // Connect Wallet
    // ----------------------------------------
    async function connect() {
      try {
        provider = new ethers.providers.Web3Provider(window.ethereum, "any");
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        userAddress = await signer.getAddress();

        const network = await provider.getNetwork();
        walletSpan.textContent = userAddress;
        networkInfo.textContent = `Connected (chainId: ${network.chainId})`;

        factory = new ethers.Contract(FACTORY_ADDRESS, factoryAbi, signer);
        pdai = new ethers.Contract(PDAI_ADDRESS, erc20Abi, provider);
        pairContract = new ethers.Contract(PAIR_ADDRESS, pairAbi, provider);

        await refreshGlobalPrice();
        await loadUserLocks();

        if (countdownInterval) clearInterval(countdownInterval);
        countdownInterval = setInterval(updateCountdowns, 1000);

      } catch (err) {
        alert("Connection failed: " + err.message);
      }
    }

    connectBtn.addEventListener("click", connect);

    // ----------------------------------------
    // PulseX Price Feed (pDAI/DAI)
    // ----------------------------------------
    async function refreshGlobalPrice() {
      try {
        const reserves = await pairContract.getReserves();
        const r0 = reserves._reserve0; // pDAI
        const r1 = reserves._reserve1; // DAI

        if (r0.isZero() || r1.isZero()) {
          globalPriceDiv.textContent = "No liquidity.";
          return;
        }

        const price1e18 = r1.mul(ethers.constants.WeiPerEther).div(r0);
        const priceFloat = parseFloat(ethers.utils.formatUnits(price1e18, 18));

        globalPriceDiv.textContent = `1 pDAI ≈ ${priceFloat.toFixed(6)} DAI`;
        globalPriceRawDiv.textContent = `raw 1e18: ${price1e18.toString()}`;
      } catch (err) {
        globalPriceDiv.textContent = "Error reading price.";
      }
    }

    setInterval(refreshGlobalPrice, 15000);

    // ----------------------------------------
    // Create Vault
    // ----------------------------------------
    createForm.addEventListener("submit", async (e) => {
      e.preventDefault();

      if (!signer) {
        alert("Connect wallet first.");
        return;
      }

      try {
        createBtn.disabled = true;
        createStatus.textContent = "Sending...";

        const priceStr = targetPriceInput.value.trim();
        const dtStr = unlockDateTimeInput.value;

        const threshold1e18 = ethers.utils.parseUnits(priceStr, 18);
        const unlockTime = Math.floor(new Date(dtStr).getTime() / 1000);

        const tx = await factory.createVault(threshold1e18, unlockTime);
        await tx.wait();

        createStatus.textContent = "Vault created!";
        await loadUserLocks();

      } catch (err) {
        createStatus.textContent = "Error: " + err.message;
      } finally {
        createBtn.disabled = false;
      }
    });

    // ----------------------------------------
    // Load Locks
    // ----------------------------------------
    async function loadUserLocks() {
      locksContainer.textContent = "Loading...";

      const iface = new ethers.utils.Interface(factoryAbi);
      const topic = iface.getEventTopic("VaultCreated");

      const logs = await provider.getLogs({
        address: FACTORY_ADDRESS,
        topics: [topic, ethers.utils.hexZeroPad(userAddress, 32)]
      });

      locks = logs.map(log => {
        const parsed = iface.decodeEventLog("VaultCreated", log.data, log.topics);
        return {
          address: parsed.vault,
          threshold: parsed.priceThreshold1e18,
          unlockTime: parsed.unlockTime.toNumber(),
          balance: ethers.constants.Zero,
          currentPrice: ethers.constants.Zero,
          canWithdraw: false,
          withdrawn: false
        };
      });

      await Promise.all(locks.map(loadVaultDetails));
      renderLocks();
    }

    async function loadVaultDetails(lock) {
      const vault = new ethers.Contract(lock.address, vaultAbi, provider);

      const [
        withdrawn,
        currentPrice,
        canWithdraw,
        balance
      ] = await Promise.all([
        vault.withdrawn(),
        vault.currentPricePDAIinDAI(),
        vault.canWithdraw(),
        pdai.balanceOf(lock.address)
      ]);

      lock.withdrawn = withdrawn;
      lock.currentPrice = currentPrice;
      lock.canWithdraw = canWithdraw;
      lock.balance = balance;
    }

    // ----------------------------------------
    // Render Locks
    // ----------------------------------------
    function renderLocks() {
      if (!locks.length) {
        locksContainer.textContent = "No locks found.";
        return;
      }

      locksContainer.innerHTML = locks.map(lock => {
        const target = parseFloat(ethers.utils.formatUnits(lock.threshold, 18));
        const current = parseFloat(ethers.utils.formatUnits(lock.currentPrice, 18));
        const bal = parseFloat(ethers.utils.formatUnits(lock.balance, 18));
        const countdown = formatCountdown(lock.unlockTime);

        let status;
        if (lock.withdrawn) status = `<span class="tag status-warn">WITHDRAWN</span>`;
        else if (lock.canWithdraw) status = `<span class="tag status-ok">UNLOCKABLE</span>`;
        else status = `<span class="tag status-bad">LOCKED</span>`;

        return `
          <div class="card">
            <div class="mono">${lock.address}</div>
            ${status}
            <div><strong>Target:</strong> 1 pDAI ≥ ${target.toFixed(6)} DAI</div>
            <div><strong>Current:</strong> ${current.toFixed(6)} DAI</div>
            <div><strong>Backup unlock:</strong> ${formatTimestamp(lock.unlockTime)}</div>
            <div><strong>Countdown:</strong> ${countdown}</div>
            <div><strong>pDAI locked:</strong> ${bal.toFixed(4)} pDAI</div>
            <button onclick="window.__withdraw('${lock.address}')"
              ${(!lock.canWithdraw || lock.withdrawn) ? "disabled" : ""}>
              Withdraw
            </button>
          </div>
        `;
      }).join("");
    }

    // ----------------------------------------
    // Withdraw
    // ----------------------------------------
    window.__withdraw = async function(vaultAddr) {
      try {
        const vault = new ethers.Contract(vaultAddr, vaultAbi, signer);
        const tx = await vault.withdraw();
        await tx.wait();
        await loadUserLocks();
      } catch (err) {
        alert("Withdraw failed: " + err.message);
      }
    };

    // ----------------------------------------
    // Utility
    // ----------------------------------------
    function formatTimestamp(ts) {
      return new Date(ts * 1000).toLocaleString();
    }

    function formatCountdown(ts) {
      const now = Math.floor(Date.now() / 1000);
      let diff = ts - now;
      if (diff <= 0) return "0s";

      const d = Math.floor(diff / 86400); diff %= 86400;
      const h = Math.floor(diff / 3600); diff %= 3600;
      const m = Math.floor(diff / 60);
      const s = diff % 60;

      const out = [];
      if (d) out.push(d + "d");
      if (h) out.push(h + "h");
      if (m) out.push(m + "m");
      out.push(s + "s");

      return out.join(" ");
    }

    function updateCountdowns() {
      if (!locks.length) return;
      renderLocks();
    }

    setInterval(refreshGlobalPrice, 15000);

  })();
  </script>

</body>
</html>
