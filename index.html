<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>pDAI Price+Time Lock</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050815;
      color: #f3f4f6;
      margin: 0;
      padding: 16px;
    }
    h1, h2 { margin-top: 0; }
    .card {
      background: #0b1020;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    }
    .row { display: flex; flex-wrap: wrap; gap: 16px; }
    .col { flex: 1 1 280px; }
    input, button {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #f9fafb;
      font-size: 14px;
    }
    input[type="datetime-local"] { color-scheme: dark; }
    button {
      cursor: pointer;
      border: none;
      background: #16a34a;
      font-weight: 600;
    }
    button[disabled] { opacity: 0.5; cursor: not-allowed; }
    label { display: block; margin-bottom: 4px; font-size: 13px; color: #9ca3af; }
    .field { margin-bottom: 12px; }
    .small { font-size: 12px; color: #9ca3af; }
    .tag {
      display: inline-block; padding: 2px 8px; border-radius: 999px;
      font-size: 11px; background: #111827; border: 1px solid #1f2937;
      margin-right: 6px; margin-top: 4px;
    }
    .status-ok { color: #4ade80; }
    .status-warn { color: #facc15; }
    .status-bad { color: #f87171; }
    .mono { font-family: monospace; font-size: 12px; }
  </style>
</head>
<body>
  <h1>pDAI Price + Time Lock</h1>

  <div class="card">
    <button id="connectBtn">Connect Wallet</button>
    <span id="walletAddress" class="mono"></span>
    <div class="small" id="networkInfo"></div>
  </div>

  <div class="row">
    <div class="col">
      <div class="card">
        <h2>Create New Lock</h2>
        <form id="createForm">
          <div class="field">
            <label for="targetPrice">Target price (DAI per 1 pDAI)</label>
            <input id="targetPrice" type="text" placeholder="e.g. 0.0100" required />
            <div class="small">
              This is stored on-chain as 1e18-scaled DAI per pDAI.
            </div>
          </div>

          <div class="field">
            <label for="unlockDateTime">Backup unlock date &amp; time</label>
            <input id="unlockDateTime" type="datetime-local" required />
            <div class="small">
              After this time, you can withdraw even if the price target isn’t met.
            </div>
          </div>

          <button type="submit" id="createBtn">Create Vault</button>
          <div class="small" id="createStatus"></div>
        </form>
      </div>
    </div>

    <div class="col">
      <div class="card">
        <h2>Global Price Feed</h2>
        <div id="globalPrice" style="margin-top:8px;font-size:14px;"></div>
        <div class="small" id="globalPriceRaw"></div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>Your Locks</h2>
    <div id="locksContainer" class="small">Connect your wallet to load locks.</div>
  </div>

  <!-- Ethers v5 -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>

  <script>
    (function () {
      // ---------- ADDRESSES ----------
      const FACTORY_ADDRESS = "0xaA5866aAA1184730Dd2926Ed83aCCbD89F128d1d";
      const PDAI_ADDRESS    = "0x6B175474E89094C44Da98B954EedeAC495271d0F";
      const DAI_ADDRESS     = "0xefd766ccb38eaf1dfd701853bfce31359239f305"; 
      const PAIR_ADDRESS    = "0x1D2be6eFf95Ac5C380a8D6a6143b6a97dd9D8712";

      // ---------- ABIs ----------
      const factoryAbi = [
        "event VaultCreated(address indexed owner, address vault, uint256 priceThreshold1e18, uint256 unlockTime)",
        "function createVault(uint256 priceThreshold1e18, uint256 unlockTime) external returns (address)"
      ];

      const vaultAbi = [
        "function owner() view returns (address)",
        "function priceThreshold() view returns (uint256)",
        "function unlockTime() view returns (uint256)",
        "function withdrawn() view returns (bool)",
        "function currentPricePDAIinDAI() view returns (uint256)",
        "function canWithdraw() view returns (bool)",
        "function withdraw() external"
      ];

      const pairAbi = [
        "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)"
      ];

      const erc20Abi = [
        "function balanceOf(address) view returns (uint256)"
      ];

      // ---------- STATE ----------
      let provider, signer, userAddress;
      let factory, pdai, pairContract;
      let locks = [];
      let countdownInterval;

      // ---------- UI ELEMENTS ----------
      const connectBtn = document.getElementById("connectBtn");
      const walletSpan = document.getElementById("walletAddress");
      const networkInfo = document.getElementById("networkInfo");
      const createForm = document.getElementById("createForm");
      const targetPriceInput = document.getElementById("targetPrice");
      const unlockDateTimeInput = document.getElementById("unlockDateTime");
      const createStatus = document.getElementById("createStatus");
      const createBtn = document.getElementById("createBtn");
      const locksContainer = document.getElementById("locksContainer");
      const globalPriceDiv = document.getElementById("globalPrice");
      const globalPriceRawDiv = document.getElementById("globalPriceRaw");

      // ---------- CONNECT WALLET ----------
      async function connect() {
        try {
          if (!window.ethereum) {
            alert("No injected wallet found (MetaMask, Rabby, etc).");
            return;
          }

          provider = new ethers.providers.Web3Provider(window.ethereum, "any");
          await provider.send("eth_requestAccounts", []);
          signer = provider.getSigner();
          userAddress = await signer.getAddress();

          const network = await provider.getNetwork();

          walletSpan.textContent = userAddress;
          networkInfo.textContent = `Connected to chainId ${network.chainId}`;

          factory = new ethers.Contract(FACTORY_ADDRESS, factoryAbi, signer);
          pdai = new ethers.Contract(PDAI_ADDRESS, erc20Abi, provider);
          pairContract = new ethers.Contract(PAIR_ADDRESS, pairAbi, provider);

          await refreshGlobalPrice();
          await loadUserLocks();

          if (countdownInterval) clearInterval(countdownInterval);
          countdownInterval = setInterval(updateCountdowns, 1000);
        } catch (err) {
          console.error(err);
          alert("Connection failed: " + err.message);
        }
      }

      // ---------- GLOBAL PRICE ----------
      async function refreshGlobalPrice() {
        if (!pairContract) return;
        try {
          const reserves = await pairContract.getReserves();
          const r0 = reserves._reserve0; // pDAI
          const r1 = reserves._reserve1; // DAI
          if (r0.isZero() || r1.isZero()) {
            globalPriceDiv.textContent = "No liquidity in pDAI/DAI pair.";
            globalPriceRawDiv.textContent = "";
            return;
          }
          const price1e18 = r1.mul(ethers.constants.WeiPerEther).div(r0);
          const priceFloat = parseFloat(ethers.utils.formatUnits(price1e18, 18));
          globalPriceDiv.textContent = `1 pDAI ≈ ${priceFloat.toFixed(6)} DAI`;
          globalPriceRawDiv.textContent = `raw (1e18): ${price1e18.toString()}`;
        } catch (err) {
          console.error(err);
          globalPriceDiv.textContent = "Error reading price.";
        }
      }

      // ---------- CREATE VAULT ----------
      async function handleCreate(e) {
        e.preventDefault();
        if (!factory || !signer) {
          alert("Connect wallet first.");
          return;
        }
        try {
          createBtn.disabled = true;
          createStatus.textContent = "Sending transaction…";

          const priceStr = targetPriceInput.value.trim();
          if (!priceStr || isNaN(Number(priceStr))) {
            alert("Enter a numeric target price.");
            createBtn.disabled = false;
            createStatus.textContent = "";
            return;
          }
          const dtStr = unlockDateTimeInput.value;
          if (!dtStr) {
            alert("Select a backup unlock date/time.");
            createBtn.disabled = false;
            createStatus.textContent = "";
            return;
          }

          const threshold1e18 = ethers.utils.parseUnits(priceStr, 18);
          const unlockTime = Math.floor(new Date(dtStr).getTime() / 1000);
          if (unlockTime <= Math.floor(Date.now() / 1000)) {
            alert("Backup time must be in the future.");
            createBtn.disabled = false;
            createStatus.textContent = "";
            return;
          }

          const tx = await factory.createVault(threshold1e18, unlockTime);
          const receipt = await tx.wait();

          createStatus.textContent = "Vault created in tx " + receipt.transactionHash;
          await loadUserLocks();
        } catch (err) {
          console.error(err);
          createStatus.textContent = "Error: " + err.message;
        } finally {
          createBtn.disabled = false;
        }
      }

      // ---------- LOAD LOCKS ----------
      async function loadUserLocks() {
        if (!provider || !userAddress) return;
        locksContainer.textContent = "Loading locks…";

        try {
          const iface = new ethers.utils.Interface(factoryAbi);
          const topic = iface.getEventTopic("VaultCreated");
          const logs = await provider.getLogs({
            address: FACTORY_ADDRESS,
            topics: [topic, ethers.utils.hexZeroPad(userAddress, 32)]
          });

          locks = logs.map(log => {
            const parsed = iface.decodeEventLog("VaultCreated", log.data, log.topics);
            return {
              address: parsed.vault,
              threshold: parsed.priceThreshold1e18,
              unlockTime: parsed.unlockTime.toNumber(),
              balance: ethers.constants.Zero,
              currentPrice: ethers.constants.Zero,
              canWithdraw: false,
              withdrawn: false
            };
          });

          await Promise.all(locks.map(loadVaultDetails));
          renderLocks();
        } catch (err) {
          console.error(err);
          locksContainer.textContent = "Error loading locks: " + err.message;
        }
      }

      async function loadVaultDetails(lock) {
        const vault = new ethers.Contract(lock.address, vaultAbi, provider);
        const [withdrawn, currentPrice, canWithdraw, balance] = await Promise.all([
          vault.withdrawn(),
          vault.currentPricePDAIinDAI(),
          vault.canWithdraw(),
          pdai.balanceOf(lock.address)
        ]);
        lock.withdrawn = withdrawn;
        lock.currentPrice = currentPrice;
        lock.canWithdraw = canWithdraw;
        lock.balance = balance;
      }

      // ---------- RENDER LOCKS ----------
      function renderLocks() {
        if (!locks.length) {
          locksContainer.textContent = "No locks found for this wallet.";
          return;
        }

        locksContainer.innerHTML = locks
          .map(lock => {
            const target = parseFloat(ethers.utils.formatUnits(lock.threshold, 18));
            const current = parseFloat(ethers.utils.formatUnits(lock.currentPrice, 18));
            const bal = parseFloat(ethers.utils.formatUnits(lock.balance, 18));
            const countdown = formatCountdown(lock.unlockTime);

            let statusTag;
            if (lock.withdrawn) statusTag = '<span class="tag status-warn">WITHDRAWN</span>';
            else if (lock.canWithdraw) statusTag = '<span class="tag status-ok">UNLOCKABLE</span>';
            else statusTag = '<span class="tag status-bad">LOCKED</span>';

            return `
              <div class="card">
                <div class="mono">${lock.address}</div>
                ${statusTag}
                <div><strong>Target:</strong> 1 pDAI ≥ ${target.toFixed(6)} DAI</div>
                <div><strong>Current:</strong> ${current.toFixed(6)} DAI</div>
                <div><strong>Backup unlock:</strong> ${formatTimestamp(lock.unlockTime)}</div>
                <div><strong>Countdown:</strong> ${countdown}</div>
                <div><strong>pDAI locked:</strong> ${bal.toFixed(4)} pDAI</div>
                <button
                  onclick="window.__withdrawFromVault('${lock.address}')"
                  ${(!lock.canWithdraw || lock.withdrawn) ? "disabled" : ""}
                >
                  Withdraw pDAI
                </button>
              </div>
            `;
          })
          .join("");
      }

      // ---------- WITHDRAW ----------
      async function withdrawFromVault(addr) {
        try {
          if (!signer) {
            alert("Connect wallet first.");
            return;
          }
          const vault = new ethers.Contract(addr, vaultAbi, signer);
          const tx = await vault.withdraw();
          await tx.wait();
          await loadUserLocks();
        } catch (err) {
          console.error(err);
          alert("Withdraw failed: " + err.message);
        }
      }
      window.__withdrawFromVault = withdrawFromVault;

      // ---------- UTIL ----------
      function formatTimestamp(ts) {
        return new Date(ts * 1000).toLocaleString();
      }

      function formatCountdown(ts) {
        const now = Math.floor(Date.now() / 1000);
        let diff = ts - now;
        if (diff <= 0) return "0s";
        const d = Math.floor(diff / 86400); diff %= 86400;
        const h = Math.floor(diff / 3600);  diff %= 3600;
        const m = Math.floor(diff / 60);
        const s = diff % 60;
        const parts = [];
        if (d) parts.push(d + "d");
        if (h) parts.push(h + "h");
        if (m) parts.push(m + "m");
        parts.push(s + "s");
        return parts.join(" ");
      }

      function updateCountdowns() {
        if (!locks.length) return;
        renderLocks();
      }

      // ---------- EVENT HOOKS ----------
      connectBtn.addEventListener("click", connect);
      createForm.addEventListener("submit", handleCreate);
      setInterval(refreshGlobalPrice, 15000);
    })();
  </script>
</body>
</html>
